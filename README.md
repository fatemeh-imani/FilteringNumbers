
<<<<<<< HEAD
﻿# NumbersFilterApp – مرحله دوم (Step 2: Enumerable & Overloading)
=======

>>>>>>> 08be3674de7d8223d1c6c03e4a1dbd4284b8319d

## توضیح کلی

در مرحله دوم پروژه، هدف این است که قابلیت دریافت و فیلتر کردن اعداد را به صورت **انعطاف‌پذیرتر** پیاده‌سازی کنیم.  
این مرحله از **Polymorphism** استفاده می‌کند تا ورودی‌ها تنها محدود به `List<int>` نباشند و بتوان از **Enumerable** یا **Array** هم استفاده کرد.

---

## ساختار پروژه

### ۱. کلاس‌ها

- **NumberService**  
  - متدهای دریافت اعداد از کاربر (`ReadNumbersFromUser`)  
  - فیلتر کردن اعداد (`FilterNumbers`)  
  - چاپ اعداد (`PrintNumbers`)  
  - در این مرحله دو رویکرد دارد:
    1. **Enumerable**: ورودی‌ها از نوع `IEnumerable<int>` دریافت می‌شوند و قابلیت استفاده با هر نوع مجموعه داده را دارند.  
    2. **Overloading**: برای انعطاف بیشتر، متد `FilterNumbers` و `ReadNumbersFromUser` با **Overloading** پیاده شده‌اند تا بتوان هم از `List<int>` و هم از `int[]` استفاده کرد.

- **ConsoleUserIO**  
  - مدیریت ورودی و خروجی کنسول به صورت استاتیک  
  - پشتیبانی از تست با کلاس **FakeConsoleUserIO**

- **Messages**  
  - پیام‌های ثابت برای ورود داده‌ها، خطاها و نتیجه

---

### ۲. تست‌ها

- دو پروژه تست ایجاد شده است:
  1. **EnumerableTests**: تست متدهای استفاده از `IEnumerable<int>`  
  2. **OverloadingTests**: تست متدهای Overloading  
     - در Overloading، متدهای `ReadNumbersFromUser` دوبار تست شده‌اند:  
       - **List<int>**  
       - **Array**  

- تمامی تست‌ها با استفاده از **FakeConsoleUserIO** پیاده شده تا ورودی و خروجی کنسول قابل شبیه‌سازی و کنترل باشد.

---

### ۳. Program.cs

در قسمت برنامه اصلی (`Program.cs`)، سه روش برای دریافت اطلاعات از کاربر پیاده شده است:

1. استفاده از **Enumerable**  
2. استفاده از **Overloading با List<int>**  
3. استفاده از **Overloading با int[]**

- پس از دریافت اعداد، متد فیلتر و چاپ بر اساس همان نوع ورودی فراخوانی می‌شود.

---

### ۴. نکات مهم

- این مرحله نشان‌دهنده **توانایی Polymorphism** در مدیریت انواع مختلف داده‌ها است.  
- طراحی تست‌ها به گونه‌ای است که تمام حالت‌ها (List، Array، IEnumerable) پوشش داده شوند.  
- کلاس‌ها و متدها همچنان به صورت **استاتیک** هستند تا مدیریت تست آسان‌تر باشد.

✔️ مزایا
1. افزایش انعطاف‌پذیری با استفاده از IEnumerable<int>

هر نوع مجموعه داده‌ای (مثل List<int>, int[], HashSet<int>) می‌تواند ورودی متدها باشد.

وابستگی به یک نوع خاص کاهش پیدا می‌کند → کاهش Coupling.

قابلیت استفاده مجدد متدها در بخش‌های دیگر پروژه.

2. نمایش قدرت Polymorphism

متدهایی که IEnumerable می‌گیرند با انواع مختلف داده، بدون نیاز به تغییر اجرا می‌شوند.

پروژه حرفه‌ای‌تر و اصول شیء‌گرایی در آن رعایت شده است.

3. پشتیبانی از Overloading

توسعه‌دهنده می‌تواند نوع دقیق ورودی را (مثلاً List یا Array) مدیریت کند.

انعطاف بیشتر در تست‌نویسی و کنترل جریان داده.

کد خواناتر می‌شود زیرا نام متد همان است اما اجرای متفاوت بر اساس نوع ورودی انجام می‌شود.

4. امکان تست‌پذیری بهتر

پروژه با FakeConsoleUserIO تست‌پذیر شده است.

جداسازی IO از Logic باعث افزایش قابلیت Unit Testing می‌شود.

رفتار ورودی/خروجی قابل شبیه‌سازی است و تست‌ها دقیق‌تر و قابل اعتمادتر هستند.

5. ساختار منظم‌تر و قابل توسعه‌تر

جداسازی وظایف (SRP):

‌NumberService = منطق

ConsoleUserIO = ورودی/خروجی

Messages = ثابت‌ها

این ساختار در مراحل بعدی قابل توسعه به Clean Architecture نیز هست.



❌ معایب

1. پیچیدگی بیشتر برای پروژه کوچک

برای افراد مبتدی درک Overloading + Polymorphism همزمان ممکن است سخت باشد.

2. احتمال تکرار کد در Overloading

اگر مدیریت نشود، چند نسخه مشابه از یک متد با ورودی‌های مختلف ایجاد می‌شود.

این مسئله Maintainability را کاهش می‌دهد.

3. اجرای کندتر نسبت به List (در موارد خاص)

IEnumerable در بعضی سناریوها Lazy است و اجرای چندباره آن هزینه‌بر می‌شود.

گاهی مجبور به تبدیل IEnumerable به List می‌شویم (ToList())، که هزینه اضافه دارد.
مثلا زمان افزودن به لیست باید از list استفاده کنیم

4. دشواری در Debug برای Enumerable

چون IEnumerable ممکن است Lazy باشد:

مقدارها همیشه از قبل مشخص نیستند.

ممکن است چند بار enumeration انجام شود.

5. پیچیدگی اضافه برای تست Overloading

چون دو نسخه از متد یکسان داریم، تست آن‌ها باید جداگانه طراحی شود.

<<<<<<< HEAD
احتمال اشتباه گرفتن نسخه لیستی و آرایه‌ای زیاد است.
=======
تمام ورودی‌ها از Fake خوانده می‌شود

تمام خروجی‌ها درون fake ذخیره می‌شود و قابل Assert است

✔️ 2. تست فیلتر

بررسی اینکه فقط اعداد بزرگ‌تر از ۵ بازگردانده شوند.

✔️ 3. تست چاپ خروجی

با بررسی اینکه پیام‌ها در fakeIO نوشته شده‌اند.

مزیت استفاده از Fake

تست‌ها ۱۰۰٪ مستقل از محیط

بدون نیاز به Console واقعی

قابل پیش‌بینی و تکرارپذیر

سرعت بیشتر
>>>>>>> 08be3674de7d8223d1c6c03e4a1dbd4284b8319d
