# NumbersFilterApp – مرحله ششم (Step 6: Yield Return)

## توضیح کلی

در مرحله ششم پروژه، هدف استفاده از **`yield return`** برای پردازش **دونه‌دونه عناصر** است.  
با این روش، می‌توانیم بدون ذخیره کل مجموعه در حافظه، عناصر را پردازش و فیلتر کنیم.

---

## مفهوم `yield return`

- وقتی در یک متد از `yield return` استفاده می‌کنیم، **هر عنصر به محض تولید شدن برگردانده می‌شود**، بدون اینکه کل مجموعه آماده باشد.  
- متدهایی که `yield return` دارند باید **نوع برگشتی `IEnumerable<T>` یا `IEnumerator<T>`** داشته باشند.  
- مصرف‌کننده می‌تواند از طریق `foreach` یا سایر روش‌های تکرار، عناصر را **یکی‌یکی دریافت کند**.

---

## مثال

```csharp
public static IEnumerable<int> FilterNumbers(List<int> numbers)
{
    foreach(var n in numbers)
        if (n > 5)
            yield return n; // هر عنصر بزرگ‌تر از 5 دونه‌دونه بازگردانده می‌شود
}

// مصرف:
foreach (var number in FilterNumbers(new List<int> { 2, 6, 10 }))
{
    Console.WriteLine(number);
}



## مزایای استفاده از yield return

مصرف کم حافظه: کل مجموعه نیازی به نگهداری در حافظه ندارد و مخصوصاً برای مجموعه‌های بزرگ مفید است.

پردازش Lazy (تنبل): عناصر فقط زمانی تولید می‌شوند که مصرف‌کننده نیاز دارد و می‌توان همزمان با تولید، پردازش کرد.

کد ساده‌تر و خواناتر: نیازی به ساخت لیست موقت برای ذخیره همه عناصر نیست و حلقه‌ها و شرط‌ها مستقیم اعمال می‌شوند.

تطبیق‌پذیری: می‌توان عناصر از منابع مختلف (لیست، آرایه، فایل یا ورودی کاربر) را دونه‌دونه پردازش کرد.


##  معایب و محدودیت‌

پیمایش مجدد محدود: اگر بخواهید IEnumerable را دوباره پیمایش کنید، باید دوباره تولید شود یا مجموعه‌ای موقت ذخیره شود.

دسترسی مستقیم به عناصر قبلی محدود: برخلاف List یا آرایه، نمی‌توان به اندیس خاصی مستقیم دسترسی داشت.

استفاده محدود در متدهای async یا void: yield return فقط در متدهای IEnumerable<T> یا IEnumerator<T> قابل استفاده است.

پیچیدگی در مدیریت State: در برخی الگوریتم‌ها که نیاز به دسترسی همزمان به چند عنصر دارند، استفاده از yield ممکن است پیچیده شود.


## نکات پیاده‌سازی در پروژه

متدهای خواندن ورودی از کاربر (ReadItemsFromUser) با yield return دونه‌دونه مقدار را برمی‌گردانند.

متدهای فیلتر کردن (FilterNumbers, FilterObjects) نیز دونه‌دونه عناصر عبوری را تولید می‌کنند.

چاپ عناصر (PrintNumbers) همانند قبل با foreach انجام می‌شود، اما عناصر همان موقع تولید شده‌اند.